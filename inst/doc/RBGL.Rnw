%
% NOTE -- ONLY EDIT RBGL.Rnw!!!
% RBGL.tex file will get overwritten.
%
%\VignetteIndexEntry{RBGL Overview}
%\VignetteDepends{graph}
%\VignetteKeywords{Graphs}
%\VignettePackage{RBGL}

\documentclass[12pt]{article}

\usepackage{amsmath,pstricks}
\usepackage[authoryear,round]{natbib}
\usepackage{hyperref}


\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}

%\setkeys{Gin}{width=0.55\textwidth}


\bibliographystyle{plainnat} 
 
\begin{document}

<<echo=false, results=hide>>=
library("RBGL")
library(Rgraphviz)
library("XML")
@

\title{{\it RBGL}: R interface to boost graph library}
\author{VJ Carey {\tt stvjc@channing.harvard.edu}}
\maketitle

\begin{quotation} {\it Summary}.  
An interface from R to the Boost Graph Library (BGL, an alternative
to STL programming for mathematical graph objects) is described.
It includes some graph algorithms built on top of those from BGL and 
some algorithms independent of those from BGL.
{\it This 2003 update employs the {\em graph} class of Bioconductor.}
\end{quotation}

\tableofcontents

\section{Basic notations/Preliminaries}

\subsection{Basics Notations}

We use the following notations:

{\em G}: a graph, represented as G = (V, E); 
{\em V} = {v1, v2, ..., vn}: a set of vertices (or nodes); 
{\em E} = {e1, e2, ..., em}: a set of edges with ei = [vj, vk], with vj, vk are in V;
{\em W} = {w1, w2, ..., wm}: a set of weights of the edges, i.e., wi is the weight on edge ei.

A {\em walk} is a sequence of vertices {v1, v2, ..., vk} such that for all i, [vi, vi+1] in {\em E}.
A {\em path} is a walk without repeated vertices.

A {\em directed} graph is a graph with direction assigned to its edges, therefore, [vj, vk] != [vk, vj].

An {\em in-degree} of vertex v is the total number of edges [u, v] in E; an {\em out-degree} of v is the total number of edges [v, u] in {\em E}.

A network {\em N} is a directed graph {\em G} with (a) a source {\em s} whose in-degree is 0, 
(b) a sink {\em t} whose out-degree is 0, and 
(c) a {\em capacity} for each edge in a network.

A {\em flow} in {\em N} assigns a value on each edge that doesn't exceed its capacity, 
all the internal vertices has the same incoming flow as the outgoing flow, 
{\em s} has outgoing flow only, {\em t} has incoming flow only.
@
 
\subsection{Examples in use}
We are going to use the following graphs repeatedly in the examples.

<<dijkstraDemo>>=
dijk <- fromGXL(file(system.file("XML/dijkex.gxl", package="RBGL")))
@
\begin{figure}
<<fig=TRUE, echo=false>>=
z <- plot(dijk)
@
\caption{Example Dijkstra example}
\end{figure}
@

<<connDemo>>=
coex <- fromGXL(file(system.file("XML/conn.gxl", package="RBGL")))
@
\begin{figure}
<<fig=TRUE, echo=false>>=
z <- plot(coex)
@
\caption{Example connectivity example 1}
\end{figure}
@

<<conn2Demo>>=
coex2 <- fromGXL(file(system.file("XML/conn2.gxl", package="RBGL")))
@
\begin{figure}
<<fig=TRUE, echo=false>>=
z <- plot(coex2)
@
\caption{Example connectivity example 2}
\end{figure}
@

<<hcsDemo>>=
hcs <- fromGXL(file(system.file("XML/hcs.gxl", package="RBGL")))
@
\begin{figure}
<<fig=TRUE, echo=false>>=
z <- plot(hcs)
@
\caption{Example highly connected subgraph example}
\end{figure}
@

<<kmstDemo>>=
km <- fromGXL(file(system.file("GXL/kmstEx.gxl", package="graph")))
@
\begin{figure}
<<fig=TRUE, echo=false>>=
z <- plot(km)
@
\caption{Example Kruskal minimum spanning tree example}
\end{figure}
@

\section{Working with the Bioconductor {\tt graph} class}
An example object representing file dependencies is included, as shown
in Figure \ref{fdpic}.  
<<showFileDep>>=
data(FileDep)
print(FileDep)
@
\begin{figure}
<<fig=TRUE, echo=false>>=
z <- plot(FileDep)
@
%\includegraphics{filedep}
\caption{File dependency digraph example from Boost library.}
\label{fdpic}
\end{figure}

\section{Algorithms from BGL}

\subsection{Depth First Search}

The {\tt dfs} function returns a list of node indices by
discovery and finish order.

<<DFSdemo1>>=
df <- fromGXL(file(system.file("XML/dfsex.gxl", package="RBGL")))
# TODO: OUTPUT NODE NAMES INSTEAD OF INDEXES???
print(o <- dfs(df))      
@
\begin{figure}
<<fig=TRUE, echo=false>>=
z <- plot(df)
@
\caption{Example dfs example}
\end{figure}
Here is the list of nodes in DFS discovery order.
<<DFSdemo2>>=
print(nodes(df)[o$discovered])
@

\subsection{Breadth First Search}
The {\tt bfs} function returns a vector of node indices
for a breadth-first search (BFS) starting at the
node indexed by {\tt init.node}.
<<BFSdemo1>>=
bf <- fromGXL(file(system.file("XML/bfsex.gxl", package="RBGL")))
# TODO: OUTPUT NODE NAMES INSTEAD OF INDEXES???
print(o <- bfs(bf,nodes(bf)[2]))  
@
\begin{figure}
<<fig=TRUE, echo=false>>=
z <- plot(bf)
@
\caption{Example bfs example}
\end{figure}

The nodes in BFS order starting with the second node are
<<BFSdemo2>>=
print(nodes(bf)[o])
@

\subsection{Shortest paths}
The shortest path problem is to find a path between two vertices where the 
sum of all the edge weights on this path is minimum.

The single-source shortest-paths problem is to find the shortest paths from 
one vertex to all the other vertices in a graph.

TO-BE-FINALIZED: 
When an edge is not available, we consider its weight {\em NA}.  When there 
is no path between two vertices, the distance between them is {\em Inf}.  
When there is a loop of negative weight between two vertices, the distance 
between them is {\em -Inf}.

{\em Dijkstra's algorithm } is for the single-source shortest-paths problem on 
graphs (directed or undirected) with non-negative weights on edges.
If all the edges have the same weight, use depth-first-search instead.

<<dijkdemo1>>=
dd <- fromGXL(file(system.file("XML/dijkex.gxl", package="RBGL")))
print( dijkstra.sp(dd) )
@
Function {\em dijkstra.sp} finds the shortest paths from {\em start A} 
to all other vertices in the graph: {\em B, C, D, E}, shown in the 
{\em distances} part.  The {\em penult} shows TO-BE-FILLED-IN.

<<dijkdemo2>>=
ospf <- fromGXL(file(system.file("XML/ospf.gxl",package="RBGL")))
dijkstra.sp(ospf,nodes(ospf)[6])
sp.between(ospf, "RT6", "RT1")
@

The first part of this example finds the shortest paths from {\em start RT6} 
to all the other vertices in the graph, and the second part finds the shortest
path between two vertices: {\em RT6} and {\em RT1}.  Since no edge weights 
are available, {\em length} and {\em pweights} are all {\em NA}.

\begin{figure}
@
<<fig=TRUE, echo=false>>=
z <- plot(ospf)
@
\caption{Network example from BGL.} 
\end{figure}


{\em Bellman-Ford's algorithm} is for the single-source shortest-paths problem 
on graphs (directed or undirected) with both positive and negative weights on 
edges.

<<bellmanfordDemo>>=
dd <- fromGXL(file(system.file("XML/conn2.gxl",package="RBGL")))
# TODO: PUT NODE NAMES AS INDEX TO DISTANCES
bellman.ford.sp(dd)
bellman.ford.sp(dd,nodes(dd)[2])
@

The first {\em bellman.ford.sp}-call shows that the shortest paths from first
vertex in the given graph, i.e., {\em start A},
to all other vertices.  The second call shows the shortest paths from 
{\em start B} to all other vertices, since there's no path from {\em B} to 
{\em A}, {\em distance} between them is {\em Inf}.

{\em DAG algorithm} is for the single-source shortest-paths problem on a 
weighted, directed acyclic graph (DAG), which is more efficient for DAG than 
both Dijkstra's and Bellman-Ford's algorithms.  When all the edges have the 
same weight, use depth-first-search instead.

<<DAGDemo>>=
dd <- fromGXL(file(system.file("XML/conn2.gxl",package="RBGL")))
# TODO: PUT NODE NAMES AS INDEX TO DISTANCES
dag.sp(dd)
dag.sp(dd,nodes(dd)[2])
@
It's easy to see that {\em conn2.gxl} doesn't contain any cycle, so we could
use function {\em dag.sp} on it.  The first call to {\em dag.sp} finds the 
shortest paths from the {\em start A} to all other vertices.  The second call
finds the shortest paths from {\em start B} to all other vertices, since no
path goes from {\em B} to {\em A}, the distance is {\em Inf}.


{\em Johnson's algorithm} finds the shortest path between every pair of 
vertices in a sparse graph.  Its time complexity is {\it O(V E log V)}.

<<johnsonDemo>>=
zz <- fromGXL(file(system.file("dot/joh.gxl", package="RBGL")))
edgeWeights(zz)
johnson.all.pairs.sp(zz)
@
\begin{figure}
<<fig=TRUE, echo=false>>=
z <- plot(zz)
@
\caption{Example Johnson-all-pairs-shortest-paths example}
\end{figure}

This example uses a graph with negative edge weights.

The shortest paths between all pairs of vertices are presented in the matrix,
entry [i, j] gives the distance from vertex {\em i} to vertex {\em j}.
For example, the shortest path from vertex {\em c} to vertex {\em d} is of 
length 5; the shortest path from vertex {\em a} to vertex {\em e} is of
length -4, since edge {\em a->e} is available and of distance -4; the shortest
distance from {\em a} to {\em c} is -3.  

{\em Floyd-Warshall's algorithm} finds the shortest path between every pair 
of vertices in a dense graph.

<<floydwarshallDemo>>=
coex <- fromGXL(file(system.file("XML/conn.gxl", package="RBGL")))
floyd.warshall.all.pairs.sp(coex)
@
All edge distances are assumed to be 1, if not given.  Since the graph is 
undirected, the distance matrix is symmetric, for example, distance from 
{\em C} to {\em G} is the same as that from {\em G} to {\em C}.

\subsection{Minimum spanning tree}

There are two algorithms available: {\em Kruskal's algorithm} and 
{\em Prim's algorithm}.  Both are for undirected graph with weighted edges.

Function {\tt mstree.kruskal} just returns a list of edges, weights and nodes
determining the minimum spanning tree (MST) by
Kruskal's algorithm.
<<KMSTdemo>>=
km <- fromGXL(file(system.file("GXL/kmstEx.gxl", package="graph")))
# TODO: OUTPUT NODE NAMES INSTEAD OF INDEXES
print(mstree.kruskal(km))
@
\begin{figure}
<<fig=TRUE, echo=false>>=
z <- plot(km)
@
\caption{Kruskal MST example from Boost library.}
\end{figure}

The graph is treated as undirected graph with corresponding weights.  
MST consists of 4 edges, each is of weight 1.

Function {\tt prim.minST} returns edges that form the minimum spanning 
tree and the weights of the edges in MST.

<<primDemo>>=
coex2 <- fromGXL(file(system.file("XML/conn2.gxl",package="RBGL")))
#TODO: OUTPUT NODE NAMES INSTEAD OF INDEXES
prim.minST(coex2)
@

The graph is treated as undirected graph with default weight 1.  MST consists
of 7 edges.

\subsection{Connected components }
There are several algorithms available for related problems.

Function {\em connectedComp} computes the connected components in an undirected graph.

<<conndemo>>=
km <- fromGXL(file(system.file("GXL/kmstEx.gxl",package="graph")))
km@nodes <- c(km@nodes,"F","G","H")
km@edgeL$F <- list(edges=numeric(0))
km@edgeL$G <- list(edges=8, weights=1)
km@edgeL$H <- list(edges=7, weights=1)
km@edgemode <- "undirected"
print(connectedComp(ugraph(km)))
@
\begin{figure}
<<fig=TRUE, echo=false>>=
z <- plot(km)
@
\caption{Modified Kruskal MST example from Boost library.}
\end{figure}

After adding three vertices, {\em F, G, H} and an edge {\em G-H}, turning
the graph into undirected, there are three components in the graph now.

Function {\em strongComp} computes the strongly connected components in a directed graph.

<<sconndemo>>=
km <- fromGXL(file(system.file("GXL/kmstEx.gxl",package="graph")))
km@nodes <- c(km@nodes,"F","G","H")
km@edgeL$F <- list(edges=numeric(0))
km@edgeL$G <- list(edges=8, weights=1)
km@edgeL$H <- list(edges=7, weights=1)
km@edgemode <- "directed"
print(strongComp(km))
@

After adding three vertices, {\em F, G, H} and an edge {\em G-H}, 
there are three components in the graph now.

A {\em biconnected} graph is a connected graph that removal of any single vertex
doesn't disconnect it.  If the removal of a vertex increases the number of 
components in a graph, this vertex is call an {\em articulation point}.
Function {\em biConnComp} computes the biconnected components in an undirected graph.
Function {\em articulationPoints} finds the all the articulation points in a graph.

<<biConnCompdemo>>=
bicoex <- fromGXL(file(system.file("XML/biconn.gxl",package="RBGL")))
# TODO: INDEX WITH NODE NAMES
print(biConnComp(bicoex))
print(articulationPoints(bicoex))
@
\begin{figure}
<<fig=TRUE, echo=false>>=
z <- plot(bicoex)
@
\caption{Biconnected components example from Boost library.}
\end{figure}

There are 4 connected components: 
one with vertices {\em A, B, E, F} and edges {\em A-B, B-E, E-F, A-F} labeled 1,
one with vertices {\em B, C, D} and edges {\em B-C, C-D, B-D} labeled 0, 
one with vertices {\em A, G} and edges {\em A-G} labeled 3, and 
one with vertices {\em G, H, I} and edges {\em G-I, G-H, I-H} labeled 2.

There are 3 articulation points: {\em A, B, G}, removing
any one of them will result more connected components in the graph. 

When you add edges to a graph and want to get updated information on the 
connected components, you could use the following functions: 
{\em init.incremental.components} to initialize the process; 
after adding edges to the graph, use {\em incremental.components} to update
the connected component information; use {\em same.component} to find out 
if two vertices are in the same component.
Currently, only one incremental graph is allowed at any given time.
To start on a new graph, you need to call {\em init.incremental.components} 
first.

<<incrCompdemo>>=
coex2 <- fromGXL(file(system.file("XML/conn2.gxl",package="RBGL")))
x <- init.incremental.components(coex2)
# TODO: OUTPUT NODE NAMES INSTEAD OF INDEXES
# TODO: MODIFY THE GRAPH TO CHANGE THE NUMBER OF CONNECTED COMPONENTS
print(incremental.components(coex2))
v1 <- 1
v2 <- 5
print(same.component(coex, v1, v2))
@

There is only one connected component in the beginning, it consists of all 
the vertices in the graph.
Vertices {\em 1} and {\em 5} are in the same connected component.

\subsection{Maximum Flow}

Functions {\em edmunds.karp.max.flow} and {\em push.relabel.max.flow} are
available to find the maximum flow between source and sink.

<<MaxFlowdemo>>=
dijk <- fromGXL(file(system.file("XML/dijkex.gxl",package="RBGL")))
edgeWeights(dijk)
edmunds.karp.max.flow(dijk, "B", "D")
push.relabel.max.flow(dijk, "C", "B")
@

Call to {\em edmunds.karp.max.flow} finds the maximum flow from vertex {\em B} 
to {\em D}: 2, one part of flow 1 is {\em B -> D} directly, another
part of flow 1 is {\em B -> E -> A -> C -> D}.

Call to {\em push.relabel.max.flow} find the maximum flow from vertex {\em C}
to {\em B}: 8, one part of flow 7 is {\em C -> B} directly, another part of
flow 1 is {\em C -> D -> E -> B}.

You can see the flow on each edge in the output, and each is no more than 
the capacity of the edge.

\subsection{Sparse Matrix Ordering}

Functions {\em cuthill.mckee.ordering}, {\em minDegreeOrdering} and
{\em sloan.ordering} are available.

{\em Cuthill-McKee's algorithm} tries to reduce the bandwidth of a graph by 
renumbering its vertices.  The outputs are the vertices in the new ordering 
and reverse ordering.

{\em Minimum degree Ordering} is one approach that tries to reduce fill-ins 
in matrix reordering, which turns a system of equations {\em A x = b} to 
{\em (P A PT)(P x) = P b}.

{\em Sloan Ordering} tries to reduce the profile and wavefront of a graph by 
renumbering its vertices.

<<SparseMatrixOrderingdemo>>=
dijk <- fromGXL(file(system.file("XML/dijkex.gxl",package="RBGL")))
coex@edgemode <- "undirected"
cuthill.mckee.ordering(dijk)
minDegreeOrdering(dijk)
sloan.ordering(dijk)
@

TODO: EXPLAIN THESE OUTPUT.

\subsection{Edge connectivity and minimum disconnecting set}

For a single connected undirected graph, function {\em edgeConnectivity} 
calculates the minimum number of edges that have to be removed to create 
two disconnected components.

<<edgeConndemo>>=
coex <- fromGXL(file(system.file("XML/conn.gxl",package="RBGL")))
print(edgeConnectivity(coex)) 
@

Mimimum of two edges must be removed to create two disconnected components:
edges {\em D-E} and {\em D-H}.

\subsection{Topological sort}

The {\tt tsort} function will return the indices of vertices
in topological sort order:

<<tsortDemo>>=
ts <- tsort(FileDep)
print(nodes(FileDep)[ts + 1])
@

Note that if the input graph is not a DAG, BGL {\tt topological\_sort}
will check this and throw 'not a dag'.  This is crudely captured
in the interface (a message is written to the console and zeroes are returned).
\begin{verbatim}
#FD2 <- FileDep
# now introduce a cycle
#FD2@edgeL[["bar_cpp"]]$edges <- c(8,1)
#tsort(FD2)
\end{verbatim}

\subsection{Layout}

Following functions are available: 

{\em randomGraphLayout} puts the vertices randomly on a plane;

{\em circle.layout} puts the vertices as vertices of a regular polygon;

{\em kamada.kawai.spring.layout} is for connected, undirected graphs, it 
treats the edges as springs and tries to minimize the energy of the whole 
system;

{\em fruchtermanReingoldForceDirectedLayout} is for unweighted, undirected,
possibly disconnected graphs, it treats the edges as forces that pull 
vertices together, no-edges as forces that push vertices apart, vertices 
move to a position as environment changes; initial positions of the vertices
are set randomly by calling {\em randomGraphLayout}.

Outputs are the coordinates of the vertices in the layout.

<<Layoutdemo>>=
coex <- fromGXL(file(system.file("XML/conn.gxl",package="RBGL")))
randomGraphLayout(coex)
circle.layout(coex)
kamada.kawai.spring.layout(coex)
@
\begin{verbatim}
------FIX THES EXAMPLES------
#fruchtermanReingoldForceDirectedLayout(coex)
\end{verbatim}
@

TODO: EXPLAIN THESE NUMBERS 

\subsection{Isomorphism}

Function {\em isomorphism} determines if two graphs are isomorphism, i.e.,
finds if there is a one-to-one mapping of vertices from one graph to the other.

<<Isomorphismdemo>>=
dijk <- fromGXL(file(system.file("XML/dijkex.gxl",package="RBGL")))
coex2 <- fromGXL(file(system.file("XML/conn2.gxl",package="RBGL")))
coex2i <- fromGXL(file(system.file("XML/conn2iso.gxl",package="RBGL")))
isomorphism(dijk, coex2)
isomorphism(coex2i, coex2)
@
\begin{figure}
<<fig=TRUE, echo=false>>=
z <- plot(coex2i)
@
\caption{Example conn2i}
\end{figure}
@

The function treats graphs as undirected, i.e., ignores the directions of the 
edges.  There are more vertices in example {\em conn2} than {dijkstra}, so
it's impossible to find a one-to-one mapping between them.
One the other hand, example {\em conn2i} is basically the same graph as {\em conn2} except the vertices have different names, so they are isomorphism.

\subsection{Vertex Coloring}

Function {\em sequential.vertex.coloring} assigns colors (as numbers 1, 2, ...)
to vertices in a graph
so that two vertices connected by an edge are of different colors.  It does not
guarantee minimum number of colors are used, and the result depends on the 
input ordering of the vertices in the graph.

<<VertexColoringdemo>>=
coex <- fromGXL(file(system.file("XML/conn.gxl",package="RBGL")))
sequential.vertex.coloring(coex)
@

We need 4 colors for the vertices of this graph, one color scheme is to give
color 0 to vertices {\em A, E}, color 1 to vertices {\em B, H}, 
color 2 to vertices {\em C, F} and color 3 to vertices {\em D, G}.

\subsection{Transitive Closure}

Function {\em transitive.closure} returns the transitive closure of a graph.

<<transClosuredemo>>=
dijk <- fromGXL(file(system.file("XML/dijkex.gxl",package="RBGL")))
transitive.closure(dijk)
@

In this graph, you can reach each vertex from any vertex.

\subsection{Wavefront, Profiles}

Functions {\em ith.wavefront}, {\em maxWavefront}, {\em aver.wavefront} and 
{\em rms.wavefront} are available.

TODO: EXPLAIN THESE TERMS

<<wavefrontdemo>>=
dijk <- fromGXL(file(system.file("XML/dijkex.gxl",package="RBGL")))
ss <- 1
ith.wavefront(coex, ss)
maxWavefront(coex)
aver.wavefront(coex)
rms.wavefront(coex)
@

\subsection{Betweenness Centrality and Clustering}

{\em Betweenness centrality} of a vertex (or an edge) measures its importance 
in a graph, i.e., among all the shortest paths between every pair of vertices 
in the graph, how many of them have to go through this vertex (or edge).
{\em Relative} betweenness centrality is calculated by scaling the {\em absolute} betweenness centrality by factor {\em 2/((n-1)(n-2))}, where {\em n} is the
number of vertices in the graph.  

Function {\em brandes.betweenness.centrality} implements Brandes' algorithm 
in calculating betweenness centrality.

Function {\em betweenness.centrality.clustering} implements clustering in a 
graph based on edge betweenness centrality.

TODO: EXPLAIN MORE

<<Centralitydemo>>=
coex <- fromGXL(file(system.file("XML/conn.gxl",package="RBGL")))
brandes.betweenness.centrality(coex)
betweenness.centrality.clustering(coex, 0.1, TRUE)
@

\section{Algorithms built on RBGL}

\subsection{Min-Cut}

Given an undirected graph G=(V, E) of a single connected
component, a {\em cut} is  a partition of the set of vertices into two
non-empty subsets S and V-S, a {\em cost} is the weight sum of edges that
are incident on one vertex in S and one vertex in V-S.  The
min-cut problem is to find a cut (S, V-S) of minimum cost.

For simplicity, subset {\em S} is the smaller of the two.

<<mincutdemo>>=
coex <- fromGXL(file(system.file("XML/conn.gxl",package="RBGL")))
print(minCut(coex))
@

TODO: FIX OR DOCUMENT: CURRENTLY all edge weights are assumed 1.
All edge weights are assumed to be 1, minimum cut is of weight 2, it will
partition the graph into two subsets: subset {\em A, B, C, D} and subset
{\em E, H, F, G}.

\subsection{highlyConnSG}

A graph {\em G} with {\em n} vertices is highly connected if its connectivity
{\em k(G) > n/2}.  Function {\em highlyConnSG} partitions a graph into a set 
of highly connected subgraphs, by using minimum-cut algorithm repeatedly. 
To improve performance, it takes special care of singletons, low degree 
vertices and merges clusters.

<<highlyConnSGdemo>>=
coex <- fromGXL(file(system.file("XML/conn.gxl",package="RBGL")))
# TODO: BETTER OUTPUT FORMAT
print(highlyConnSG(coex))
hcs <- fromGXL(file(system.file("XML/hcs.gxl",package="RBGL")))
print(highlyConnSG(hcs))
@

In graph {\em conn}, two highly-connected-subgraphs are found: subgraph 
with vertices {\em A, B, C, D} and subgraph with vertices {\em E, H, F, G}.

In graph {\em hcs}, 3 highly-connected-subgraphs are found: subgraph with vertices {\em A1, A2, A3, A4, A5}, subgraph with vertices {\em B1, B2, B3, B4} and subgraph with vertices {\em X, Y, Z}.


\section{Algorithms independent from RBGL}
\subsection{maxClique}

A {\em clique} is a complete graph.  
Function {\em maxClique} finds all the cliques in a graph.  

<<MaxCliquedemo>>=
coex <- fromGXL(file(system.file("XML/conn.gxl",package="RBGL")))
print(maxClique(coex))
hcs <- fromGXL(file(system.file("XML/hcs.gxl",package="RBGL")))
print(maxClique(hcs))
@

In graph {\em conn}, 3 cliques are found: 
clique with vertices {\em D, B, C, A},
clique with vertices {\em D, E, H} and 
clique with vertices {\em F, E, H, H}.

In graph {\em hcs}, 10 cliques are found.  For instance, vertices {\em A2, A4, A3} form a clique, vertices {\em B1, Y} form a clique.

\subsection{is.triangulated}

A graph is {\em triangulated} if all cycles of length 4 or more have a chord.
Function {\em is.triangulated} returns TRUE or FALSE, accordingly.

<<IsTriangulateddemo>>=
coex <- fromGXL(file(system.file("XML/conn.gxl",package="RBGL")))
print(is.triangulated(coex))
coex <- fromGXL(file(system.file("XML/hcs.gxl",package="RBGL")))
print(is.triangulated(coex))
@

\subsection{separates}

Function {\em separates} determines if a subset of vertices separates two other
subsets of vertices, and returns TRUE or FALSE, accordingly.

<<Separatesdemo>>=
coex <- fromGXL(file(system.file("XML/kmstEx.gxl",package="RBGL")))
print(separates("B", "A", "E", km))
print(separates("B", "A", "C", km))
@

\end{document}


