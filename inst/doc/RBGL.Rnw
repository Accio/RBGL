%
% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
\documentclass[12pt]{article}

\usepackage{amsmath,pstricks}
\usepackage[authoryear,round]{natbib}
\usepackage{hyperref}


\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}

%\setkeys{Gin}{width=0.55\textwidth}


\bibliographystyle{plainnat} 
 
\begin{document}

\title{{\it RBGL}: R interface to boost graph library}
\author{VJ Carey {\tt stvjc@channing.harvard.edu}}
\maketitle

\begin{quotation} {\it Summary}.  A very preliminary implementation
of an interface from R to the Boost Graph Library (BGL, an alternative
to STL programming for mathematical graph objects) is presented.
\end{quotation}

\section{Working with a simple S4 graph class}
The {\it RBGL} package includes an S4 class for
representing directed graphs by vertex and edge lists.  The
class is called {\tt graf} and an example object
representing file dependencies is included, as shown
in Figure \ref{fdpic}.  The figure is made with the {\tt toDot}
function, which will work on any system where the ATT graphViz {\tt dot}
utility is available.  
<<>>=
library(RBGL)
data(FileDep)
print(FileDep)
# if dot is available, this will work
x <- toDot(FileDep, outDotFile="fd.dot") 
try( system("dot -Tps fd.dot > fd.ps") )
@
\setkeys{Gin}{width=0.55\textwidth}
\begin{figure}
\begin{center}
\includegraphics{fdep.ps}
\end{center}
\caption{File dependency digraph example from Boost library.}
\label{fdpic}
\end{figure}

\clearpage

The {\tt tsort} function will return the indices of vertices
in topological sort order:
<<>>=
print(ts <- tsort(FileDep))
print(vertices(FileDep)[ts + 1])
@
Note that if the input graph is not a DAG, BGL {\tt topological\_sort}
will check this and throw 'not a dag'.  This is crudely captured
in the interface (a message is written to the console and zeroes are returned):
<<>>=
FD2 <- FileDep
FD2@edges[[20]] <- c("bar_cpp", "dax_h")
print(tsort(FD2))

@
\section{Dealing with edge attributes}
Currently there is a crude mechanism for attaching edge costs.
<<>>=
FD3 <- FileDep
setEdgeCosts(FD3) <- runif(19)
print(FD3)
print(edgeCosts(FD3))
@

\section{Quick look at RBGL with {\it sna} rgraph}
The {\it sna} package on CRAN uses an S3 class called {\tt graph},
based on an adjacency matrix representation.  Adjacency matrices
are converted to adjacency list representation using {\tt Am2Al}
in {\it RBGL}.
<<>>=
library(sna)
@
Make a random graph with 5 vertices:
<<>>=
set.seed(123)
GG <- rgraph(5,1)
print(GG)
@
Print the 'list form':
<<>>=
print(GGl <- Am2Al(GG))
@
Build the {\tt graf} analog, then try a topological sort:
<<>>=
GGE <- list()
for (i in 1:ncol(GGl)) GGE[[i]] <- GGl[,i]
uan <- function(x) sort(unique(as.numeric(x)))
GGV <- uan(GGl)
sGG <- new("graf", edges=as.edgeStruct(GGE), vertices=GGV)
toDot(sGG,outDotFile="sGG.dot")
try( system("dot -Tps sGG.dot > sGGd.ps") )
print(sGG)
print(tsort(sGG))
@

We can see why the topological sort fails:


\setkeys{Gin}{width=0.25\textwidth}
\begin{figure}
\begin{center}
\includegraphics{sGG.ps}
\end{center}
\caption{Random graph.}
\label{sggpic}
\end{figure}

\clearpage



@
Let's define a converter for {\it sna} graphs to
objects of class {\tt graf}:

<<>>=
snag2graf <- function(x) {
 m <- Am2Al(x)
 o <- list()
 for (i in 1:ncol(m)) o[[i]] <- m[,i]
 v <- sort(unique(as.numeric(m)))
 new("graf", edges=as.edgeStruct(o), vertices=v)
}
@
Now let's make a big random graph:
<<>>=
rg <- rgraph(14,1)
gg <- snag2graf(rg)
toDot(gg, outDotFile="gg.dot")
try( system( "dot -Tps gg.dot > ggd.ps") )
@

\setkeys{Gin}{width=1.25\textwidth}
\begin{figure}[H]
\begin{center}
\includegraphics{gg.ps}
\end{center}
\caption{Large random graph from sna.}
\label{rgra}
\end{figure}

\clearpage
@
\section{Rendering application: looking at GO}

The GO data package is an example of  a DAG.  We should
be able to usefully visualize aspects of this using our
graf class.

We'll begin with the visualization of the cellular
component hierarchy:

<<>>=
library(GO)
cc <- ls(env=GOcellularcomponent)
print(cc[1])
@
We see that the environment
consists of alphanumeric tags defining GO terms.
Each tag is bound to a vector of tags:
<<>>=
print(get(cc[1], env=GOcellularcomponent))
@
Order here is significant: as we move from left to
right, we get less specific in the GO hierarchy.

Let's visualize the DAG to depth three.  To do this,
we will isolate the three-vectors that conclude the
path from each leaf to the root.  We will obtain the
unique set of edges by some character manipulations,
then build the associated graph for rendering.

First we set up a function that extracts adjacent pairs
from any vector:
<<>>=
adjprs <- function(x) {
if (length(x)==1) NULL
 else c(x[1],x[2], adjprs(x[-1]))
}
adjpairs <- function(x) {a <- adjprs(x);
if (length(a) <= 1) return(NULL)
b <- list();
for (i in seq(1,length(a),2)) b[[floor((i+1)/2)]] <- a[i:(i+1)]
b
}

@
Then we obtain the paths to all GO leaves:

<<>>=
nleaves <- length(cc)
allv <- list()
for (i in 1:nleaves) allv[[i]] <- get(cc[i], env=GOcellularcomponent)

@
Now we get the edges and nodes of the associated tree:
<<>>=

upairs <- function(x) {
xp <- lapply(x,function(x)lapply(x,function(y)paste(y,collapse=";")))
uxp <- unique(unlist(xp))
strsplit(uxp,";")
}


preGOEdges <- lapply(allv, function(x)adjpairs(rev(x)))
GOEdges <- upairs(preGOEdges)
GONodes <- unique(unlist(GOEdges))

gog <- makeGraf(V=GONodes, E=GOEdges)
toDot(gog,"gog.dot")
@
After running the unix command
\begin{verbatim}
dot -Gsize=8,8 -Grotate=90 -Tps -Nfontsize=1 
          -Nfixedsize=true -Nheight=.2 -Nwidth=.2 
          -Gratio=fill gog.dot > gog.ps
\end{verbatim}
We can see the basic topology of the tree.

\setkeys{Gin}{width=1.\textwidth}
\begin{figure}
\includegraphics{gog.ps}
\end{figure}
@
Wrapping this all together, we can generate graf objects
from any GO environment:
<<>>=
GO2graf <- function(env) {
goe <- ls(env=env)
adjprs <- function(x) {
 if (length(x)==1) NULL
  else c(x[1],x[2], adjprs(x[-1]))
 }
adjpairs <- function(x) {a <- adjprs(x);
 if (length(a) <= 1) return(NULL)
 b <- list();
 for (i in seq(1,length(a),2)) b[[floor((i+1)/2)]] <- a[i:(i+1)]
 b
}
nleaves <- length(goe)
allv <- list()
for (i in 1:nleaves) allv[[i]] <- get(goe[i], env=env)

upairs <- function(x) {
xp <- lapply(x,function(x)lapply(x,function(y)paste(y,collapse=";")))
uxp <- unique(unlist(xp))
strsplit(uxp,";")
}

preGOEdges <- lapply(allv, function(x)adjpairs(rev(x)))
GOEdges <- upairs(preGOEdges)
GONodes <- unique(unlist(GOEdges))

makeGraf(V=GONodes, E=GOEdges)
}
@
That finishes the function.  Now apply it to two more environments:

<<>>=
mfg <- GO2graf( GOmolecularfunction )
bpg <- GO2graf( GObiologicalprocess )

@
And render:
<<>>=
toDot(mfg,"mf.dot")
@
\begin{figure}
\includegraphics{mf.ps}
\caption{Molecular function}
\end{figure}
\begin{figure}
\includegraphics{bp.ps}
\caption{Biological process}
\end{figure}

@
\end{document}


